---
title: "Capstone - Principal Component Analysis"
author: "Nick Belgau, Oscar Hernandez Mata"
date: '`r Sys.Date()`'
format:
  html:
    code-fold: true
course: STA 6257 - Advanced Statistical Modeling
bibliography: references.bib # file contains bibtex for references
#always_allow_html: true # this allows to get PDF with HTML features
self-contained: true
execute: 
  warning: false
  message: false
editor: 
  markdown: 
    wrap: 72
---


### Application 1: General Dimensionality Reduction
Load required libraries:
```{r}
library(readxl)
library(skimr)
library(dplyr)
library(ggplot2)
library(corrplot)
library(scales)
library(DescTools)
library(reshape2)
library(factoextra)
library(readr)
library(kableExtra)
library(rrcov)
library(psych)

library(corrplot)
library(gridExtra)

```

1.  **Dataset Description**

The dataset contains demographic, health, and environmental metrics for counties in Florida (FL) and Georgia (GA). Each row represents data for a specific county, and the selected columns are:

- County: Name of the county.
- State: State abbreviation (FL or GA).
- obesity_age_adj: Age-adjusted obesity rate.
- Smoking_Rate: Rate of smoking within the population.
- physical_inactivity: Rate of physical inactivity.
- Diabetes: Diabetes prevalence rate.
- Heart_Disease: Heart disease prevalence rate.
- Cancer: Cancer prevalence rate.
- NATA_Cancer_11: National-Scale Air Toxics Assessment (NATA) cancer risk for 2011.
- Poverty_Percent: Percentage of the population living below the poverty line.

```{r}
url <- "https://raw.githubusercontent.com/nickbelgau/STA6257_PCA/main/data/Alz_mortality_data_complete_with_state_csv.csv"
data_raw <- read_csv(url)
```


2.  **Filtered Dataset and Inspection**

```{r}
selected_columns <- c(
  "County", "State", "obesity_age_adj", "Smoking_Rate", "Diabetes", "Heart_Disease", "Cancer",  "Mercury_TPY", "Lead_TPY", "Food_index", "Poverty_Percent", "Atrazine_High_KG", "SUNLIGHT"
)

deep_south_states <- c("AL", "AR", "FL", "GA", "LA", "MS", "NC", "SC", "TN", "TX", "VA")

data <- data_raw %>%
  filter(State %in% deep_south_states) %>%
  select(all_of(selected_columns))

data <- data %>%
  select(-County, -State)
```


The correlation matrix plots show enough of a relationship between variables to meet the assumption of linearity.

4.  **Outliers analysis**
```{r}
# Set up the plotting area to accommodate five plots per variable: boxplot, histogram, and spacing
par(mfrow = c(2, 1), mar = c(3, 3, 2, 1))

# Function to identify outliers using the 1.5 * IQR rule
identify_outliers <- function(x) {
  q1 <- quantile(x, 0.25)
  q3 <- quantile(x, 0.75)
  iqr <- q3 - q1
  lower_bound <- q1 - 1.5 * iqr
  upper_bound <- q3 + 1.5 * iqr
  return(x[x < lower_bound | x > upper_bound])
}

for (i in names(data)) {
  # Boxplot
  boxplot(data[[i]], horizontal = TRUE, main = paste("Boxplot of", i), ylab = "Values", col = "lightblue")
  
  # Histogram and Density plot
  hist(data[[i]], probability = TRUE, main = paste("Density Plot of", i), xlab = "Values", col = "lightblue", border = "darkblue")
  lines(density(data[[i]]), col = "darkred", lwd = 2)

  # Identify and print outliers
  outliers <- identify_outliers(data[[i]])
  cat(paste("Outliers for", i, ":", paste(outliers, collapse = ", "), "\n"))
  
  # Add spacing if needed or you could plot something else or adjust the number of plots per page

}


```


Box Cox transform
```{r}
# Load necessary package for Box-Cox transformation
library(MASS)

data_transform <- data

# Function to apply Box-Cox transformation to specified columns and return separately
box_cox_transform <- function(df, columns) {
  transformed_df <- df
  lambdas <- list()
  
  for (col in columns) {
    col_data <- df[[col]]
    col_data[col_data <= 0] <- min(col_data[col_data > 0]) / 2  # Handle non-positive values
    bc <- boxcox(col_data ~ 1, plotit = FALSE)
    lambda <- bc$x[which.max(bc$y)]
    transformed_df[[col]] <- (col_data^lambda - 1) / lambda
    lambdas[[col]] <- lambda
  }
  
  return(list(transformed_df, lambdas))
}


# Columns to transform
columns_to_transform <- c("Lead_TPY", "Mercury_TPY", "Atrazine_High_KG")

# Apply Box-Cox transformation
result <- box_cox_transform(data_transform, columns_to_transform)
data_transform <- result[[1]]
lambdas <- result[[2]]

# Print lambda values
print("Lambda values used for transformation:")
print(lambdas)

# Set up the plotting area
par(mfrow = c(length(columns_to_transform) + 1, 1), mar = c(4, 4, 2, 1))  # Adjust margins as needed

for (i in columns_to_transform) {
  # Histogram and Density plot
  hist(data_transform[[i]], probability = TRUE, main = paste("Density Plot of", i), xlab = "Values", col = "lightblue", border = "darkblue")
  lines(density(data_transform[[i]]), col = "darkred", lwd = 2)
}



```

```{r}
pca_result <- prcomp(data, center = TRUE, scale. = TRUE)

pca_summary <- summary(pca_result)
importance <- as.data.frame(pca_summary$importance)
importance <- t(importance) # transpose to make cleaner
colnames(importance) <- c("Std Dev", "Proportion", "Cumulative Var")
importance
```


```{r}
pca_result <- prcomp(data_transform, center = TRUE, scale. = TRUE)

pca_summary <- summary(pca_result)
importance <- as.data.frame(pca_summary$importance)
importance <- t(importance) # transpose to make cleaner
colnames(importance) <- c("Std Dev", "Proportion", "Cumulative Var")
importance
```